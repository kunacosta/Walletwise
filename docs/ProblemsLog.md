# Problems Log

| Date | Area | Problem | Root Cause | Fix | Outcome |
|------|------|---------|------------|-----|---------|
| 2025-02-11 | Transaction modal | Modal reopened with stale values and allowed zero/invalid amounts, leading to malformed Firestore payloads. | The form state was retained between openings and category validation did not run when switching transaction types. | Reinitialize modal state on open, guard category/subcategory consistency, and validate payloads before submission. | Tested by reopening the modal, toggling type, and confirming only sanitized payloads are dispatched. |
| 2025-02-11 | Optimistic updates | Ledger stalled or left partial edits when Firestore writes failed. | UI waited for remote writes and offered no rollback or error surface. | Introduced optimistic create/update flows with temp entries, rollback on failure, and toast messaging. | Confirmed temp entries are removed after success and failures restore prior values with error toasts. |
| 2025-02-11 | Ledger subscriptions | Duplicate listeners caused repeated/out-of-order transactions and hid Firestore listener failures. | Each login change layered a new subscription without clearing the previous one and errors were swallowed. | Track and dispose the previous unsubscribe handle, always sort transactions locally, and bubble errors into ledger toasts. | Observed a single active listener per user and stable ordering while error toasts display when forced failures occur. |
| 2025-02-11 | Auth/data guards | Unauthorized writes fired during auth transitions and zero-amount transactions slipped through. | Firestore operations did not assert auth readiness or positive amounts and protected routes rendered before auth settled. | Enforce auth checks and amount validation in db services, enable Firestore persistent cache, and gate routes behind a loading spinner. | Verified app startup and protected navigation to ensure no unauthenticated writes or early route flashes occur. |

